# Run a set of Ruby QuickCheck properties
def RQC(&block)
  RQC.run(&block) if block_given?
end

module RQC
  extend self

  # Collects properties from the block and runs them
  def run(&block)
    clear
    set_defaults
    RQC.module_eval(&block)
    execute
  end

  # The list of defined properties
  def props
    @props ||= []
  end

  # Clears the defined properties
  def clear
    @props = []
  end

  # Executes each property, outputting the result to STDOUT
  def execute
    @props.each do |p|
      puts p.run.to_s
    end
  end

  # Defines a property to be checked
  # @param [String] name a descriptive name for the property
  # @param [Array<generator>] gens a list of generators for the property
  # @yield |gen_values*| values generated by the specified generators
  #                      (in the same order as defined on the property)
  def property(name, *gens, &block)
    props << Property.new(name, *gens, &block)
  end

  # @return [Integer] The maximum number of shrinking passes
  attr :max_shrink
  # @return [Integer] The maximum number of allowable invalid test cases
  attr :max_invalid
  # @return [Integer] The maximum number of allowable passing test cases
  attr :max_pass

  # Shrinks a failed test case to its minimum failing case
  # @private
  def shrink_loop(property, size, args)
    return args
    failedArgs = [args]
    shrinkedArgs = []
    0.upto(max_shrink) do |loop|
      shrinkedArgs = []
      failedArgs.each do |farg|
        shrinkedArgs += property.generate_shrinked_args(size, farg)
      end

      if shrinkedArgs.empty?
        return failedArgs.empty? ? nil : failedArgs[0]
      end

      failedArgs = []
      shrinkedArgs.each do |sargs|
        begin
          testCase = new Case(sargs)
          testCase.instance_exec(*sargs, &property.block)
        rescue InvalidCase
          next
        rescue FailedAssertion
          if loop == max_shrink - 1
            return sargs
          else
            failedArgs << sargs
          end
        end
      end
    end
  end

  # Sets the default configuration values
  # @private
  def set_defaults
    @max_pass = 100
    @max_invalid = 100
    @max_shrink = 10
  end

  # Given a generator and a size/entropy, generates a value
  # @private
  def generate_value(gen, size)
    gen.respond_to?(:__generate__) ? gen.__generate__(size) : gen.call(size)
  end

  # Determines whether to continue generating test cases
  # @private
  def needs_work?(stats)
    stats.invalid < self.max_invalid && stats.pass < self.max_pass
  end

  # # Some basic generators
  # def frequency(*gens)
  #   d = Distribution.new(gens.to_a)
  #   d.method(:pick)
  # end

  # def choose(*gens)
  #   d = Distribution.uniform(gens)
  #   d.method(:pick)
  # end

  # def randWhole(top)
  #   rand(top)
  # end

  # def randInt(top)
  #   rand(2 * top) - top
  # end

  # def randRange(a,b)
  #   rand(a-b) + a
  # end

  # def randFloatUnit
  #   rand
  # end

  # Generates a random boolean (true or false). Shrinks to false.
  def boolean
    Class.new do
      def __generate__(size)
        rand(2) == 1 ? true : false
      end
      def __shrink__(size,arg)
        [false]
      end
      def inspect
        "boolean()"
      end
    end.new
  end

  # Generates a random value in the given numeric range. Shrinks to the
  # beginning of the range.
  # @overload choose(rng)
  #   @param [Range] rng the range of integers to generate a value
  #                  within
  # @overload choose(low, high)
  #   @param [Integer] low the low end of the range
  #   @param [Integer] high the high end of the range
  def choose(*args)
    range = args.length == 2 ? Range.new(args[0],args[1]) : args.first
    Class.new do
      def initialize(r); @range = r; end
      def __generate__(size)
        span = @range.end - @range.begin
        rand(span) + @range.begin
      end
      def __shrink__(size,arg)
        [range.begin]
      end
      def inspect
        "choose(#{@range.inspect})"
      end
    end.new(range)
  end

  # Generates a random element from the array. Shrinks to an element
  # toward the front of the array.
  # @param [Array] list an array/list of possible values for the generator
  def elements(list)
    Class.new do
      def initialize(l); @list = l; end
      def __generate__(size)
        size = [@list.size,size].min
        @list[rand(size)]
      end
      def __shrink__(size,arg)
        idx = @list.index(arg)
        [@list[ [0,idx-1].max ]]
      end
      def inspect
        "elements(#{@list.inspect})"
      end
    end.new(list)
  end

  # Generates an array containing values generated from the passed
  # generator. Shrinks by removing elements from the end of the
  # array.
  # @param [generator] item a generator for elements of the generated array
  def array(item)
    Class.new do
      def initialize(i)
        @item = i
      end
      def __generate__(size)
        size = rand(size).to_i
        [].tap do |arr|
          size.times { arr << RQC.generate_value(@item,size) }
        end
      end
      def __shrink__(size,arg)
        arg.empty? ? [] : [arg[0..-2]]
      end
      def inspect
        "array(#{@item.inspect})"
      end
    end.new(item)
  end

  # Generates a value using a randomly chosen element of the list of
  # generators.
  # @param [Array<generator>] list a list of generators
  def one_of(list)
    Class.new do
      def initialize(l); @list = l; end
      def __generate__(size)
        idx = rand(@list.size)
        RQC.generate_value(@list[idx], size)
      end
      def inspect
        "one_of(#{@list.inspect})"
      end
    end.new(list)
  end

  # Generates a string containing ASCII characters between 32 and 255.
  # Shrinks to a shorter string.
  def ascii_string
    Class.new do
      include RQC
      def __generate__(size)
        str = RQC.generate_value(array(choose(32,255)), size)
        str.pack("C*")
      end
      def __shrink__(size,arg)
        arg.empty? ? [""] : [arg[0..-2]]
      end
      def inspect
        "ascii_string()"
      end
    end.new
  end

  # Generates the passed value. Shrinks to the passed value.
  def constant(value)
    Class.new do
      def initialize(v); @value = v; end
      def __generate__(size)
        @value
      end
      def __shrink__(size,arg)
        [@value]
      end
      def inspect
        @value.inspect
      end
    end.new(value)
  end

  # Generates an integer bound by the generation size. Shrinks toward 0.
  def int
    Class.new do
      def __generate__(size)
        rand(2*(size**2)) - (size**2)
      end

      def __shrink__(size,arg)
        if size > 0
          [__generate__(size-1)]
        else
          [0]
        end
      end
      def inspect
        "int()"
      end
    end.new
  end

  # Defines a transformation on another generator. Doesn't support
  # shrinking.
  # @param [generator] gen the generator for transformation
  # @yield [value] a value created from the generator
  def let(gen, &block)
    Class.new do
      def initialize(g,b,c); @gen = g; @block = b; @context = c end
      def __generate__(size)
        base = RQC.generate_value(@gen, size)
        @block.call(base)
      end
      def inspect
        "let[#{@context}](#{@gen.inspect})"
      end
    end.new(gen, block, caller)
  end

  # Defines a transformation on another generator that supports
  # shrinking by transforming the shrinked value.
  # @param [generator] gen the generator for transformation
  # @yield [value] a value created from the generator
  def let_shrink(gen, &block)
    Class.new do
      def initialize(g,b,c); @gen = g; @block = b; @context = c end
      def __generate__(size)
        base = RQC.generate_value(@gen, size)
        @block.call(base)
      end
      def __shrink__(size,arg)
        if @gen.respond_to?(:__shrink__)
          Array(@gen.__shrink__(size-1,arg)).map(&@block)
        else
          arg
        end
      end
      def inspect
        "let_shrink[#{@context}](#{@gen.inspect})"
      end
    end.new(gen, block, caller)
  end

  # Exceptions
  class FailedAssertion < StandardError; end
  class InvalidCase < StandardError; end

  # Results
  PropertyResult = Struct.new(:property, :stats)
  class PropertyPass < PropertyResult; end
  class PropertyInvalid < PropertyResult; end
  PropertyFailure = Struct.new(:property, :stats, :args, :shrinked, :tags, :dist)

  # The context within which a property block runs
  class Case
    attr_reader :args, :tags, :collected
    def initialize(args)
      @args, @tags, @collected = args, [], Hash.new(0)
    end

    # Assert that the argument is true, or fail the property
    def assert(test)
      raise FailedAssertion.new unless test
    end

    # 
    def guard(test)
      raise InvalidCase.new unless test
    end

    def classify(test, tag)
      tags << tag if test
    end

    def collect(value)
      @collected[value] += 1
    end

    def note_arg(arg)
      @args << arg
    end
  end

  class Stats
    attr_accessor :invalid, :pass, :tags, :collected
    def initialize
      @pass, @invalid, @tags, @collected = 0, 0, Hash.new(0), nil
    end

    def invalid!
      @invalid += 1
    end

    def pass!
      @pass += 1
    end

    def add_tags(tags)
      tags.each do |t|
        @tags[t] += 1
      end
    end

    def new_result(prop)
      @pass > 0 ? PropertyPass.new(prop,self) : PropertyInvalid.new(prop,self)
    end

    def to_s
      "(pass=#{@pass}, invalid=#{@invalid})"
    end
    alias :inspect :to_s
  end

  # Not used yet, but ported over from qc.js
  class Distribution
    def self.uniform(data)
      new(Hash[*data.map {|i| [i, 1] }])
    end

    def initialize(d)
      @data = Hash.new(0)
      d.each do |pair|
        @data[pair[0]] += pair[1]
      end
      normalize
    end

    def normalize
      sum = @data.values.reduce(:+)
      @data.each_key {|k| @data[k] /= sum }
    end

    def probability(x)
      @data[x]
    end

    def most_probable
      maxval = @data.values.max
      @data.rassoc(maxval).first
    end

    def pick
      s, r = 0, rand
      @data.to_a.each do |(k,v)|
        s += v
        return k if r < s
      end
    end
  end

  class Property
    attr_reader :name, :generators, :block
    def initialize(name, *generators, &block)
      @name, @generators, @block = name, generators, block
    end

    def run
      stats, size, collected = Stats.new, 0, []
      while RQC.needs_work?(stats)
        args = generate_args(size)
        test_case = Case.new(args)
        begin
          test_case.instance_exec(*args, &@block)
          stats.pass!
        rescue FailedAssertion
          dist = test_case.collected.empty? ? nil : Distribution.new(test_case.collected)
          shrinked_args = RQC.shrink_loop(self, size, args)
          return PropertyFailure.new(self, stats, args, shrinked_args, test_case.tags, dist)
        rescue InvalidCase
          stats.invalid!
        end
        size += 1
        stats.add_tags(test_case.tags)
        collected += test_case.collected.to_a
      end

      stats.collected = collected.empty? ? nil : Distribution.new(collected)

      return stats.new_result(self)
    end

    def generate_args(size)
      @generators.map {|g| RQC.generate_value(g,size) }
    end

    def generate_shrinked_args(size, args)
      # create shrinked args for each argument
      count_shrinked = 0
      shrinked = @generators.map do |gen|
        if !gen.respond_to?(:__shrink__) || gen.respond_to?(:call)
          [args.shift]
        else
          tmp = gen.__shrink__(size, args.first)
          if !tmp || (tmp.respond_to?(:empty?) && tmp.empty?)
            [args.shift]
          else
            count_shrinked += 1
            tmp
          end
        end
      end
      return [] if count_shrinked.zero?
      # Create index list to draw lists of arguments from
      idxs = [0] * @generators.size
      # Create list of shrinked arguments
      newArgs = []
      while idxs.first < shrinked.first.length
        tmp = []
        shrinked.each_with_index do |s,i|
          tmp[i] = s[idxs[i]]
        end
        newArgs << tmp

        # adjust all indices
        (shrinked.length - 1).downto(0) do |i|
          idxs[i] += 1
          idxs[i] = 0 if !i.zero? && idxs[i] >= shrinked[i].length
        end
      end
    end

    def generate_shrinked(gen, size, arg)
      return [] if !gen || !gen.respond_to?(:__shrink__) || gen.respond_to?(:call)
      tmp = gen.__shrink__(size, arg)
      return tmp.nil? ? [] : tmp
    end
  end
end
